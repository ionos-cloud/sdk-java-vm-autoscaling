/*
 * VM Auto Scaling API
 * The VM Auto Scaling Service enables IONOS clients to horizontally scale the number of VM replicas based on configured rules. You can use VM Auto Scaling to ensure that you have a sufficient number of replicas to handle your application loads at all times.  For this purpose, create a VM Auto Scaling Group that contains the server replicas. The VM Auto Scaling Service ensures that the number of replicas in the group is always within the defined limits.   When scaling policies are set, VM Auto Scaling creates or deletes replicas according to the requirements of your applications. For each policy, specified 'scale-in' and 'scale-out' actions are performed when the corresponding thresholds are reached.
 *
 * The version of the OpenAPI document: 1-SDK.1
 * Contact: support@cloud.ionos.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.ionoscloud.vmautoscaling.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.ionoscloud.vmautoscaling.model.BusType;
import com.ionoscloud.vmautoscaling.model.VolumeHwType;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;
import org.openapitools.jackson.nullable.JsonNullable;

/**
 * ReplicaVolumePost
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2023-10-25T09:34:22.361740Z[Etc/UTC]")

public class ReplicaVolumePost {
  
  public static final String SERIALIZED_NAME_IMAGE = "image";
  @SerializedName(SERIALIZED_NAME_IMAGE)
  private UUID image;


  public static final String SERIALIZED_NAME_IMAGE_ALIAS = "imageAlias";
  @SerializedName(SERIALIZED_NAME_IMAGE_ALIAS)
  private String imageAlias;


  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;


  public static final String SERIALIZED_NAME_SIZE = "size";
  @SerializedName(SERIALIZED_NAME_SIZE)
  private Integer size;


  public static final String SERIALIZED_NAME_SSH_KEYS = "sshKeys";
  @SerializedName(SERIALIZED_NAME_SSH_KEYS)
  private List<String> sshKeys = null;


  public static final String SERIALIZED_NAME_TYPE = "type";
  @SerializedName(SERIALIZED_NAME_TYPE)
  private VolumeHwType type;


  public static final String SERIALIZED_NAME_USER_DATA = "userData";
  @SerializedName(SERIALIZED_NAME_USER_DATA)
  private String userData;


  public static final String SERIALIZED_NAME_BUS = "bus";
  @SerializedName(SERIALIZED_NAME_BUS)
  private BusType bus = BusType.VIRTIO;


  public static final String SERIALIZED_NAME_BACKUPUNIT_ID = "backupunitId";
  @SerializedName(SERIALIZED_NAME_BACKUPUNIT_ID)
  private String backupunitId;


  /**
   * Determines whether the volume will be used as a boot volume. Set to NONE, the volume will not be used as boot volume. Set to PRIMARY, the volume will be used as boot volume and set to AUTO will delegate the decision to the provisioning engine to decide whether to use the voluem as boot volume. Notice that exactly one volume can be set to PRIMARY or all of them set to AUTO.
   */
  @JsonAdapter(BootOrderEnum.Adapter.class)
  public enum BootOrderEnum {
    AUTO("AUTO"),
    
    NONE("NONE"),
    
    PRIMARY("PRIMARY");

    private String value;

    BootOrderEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static BootOrderEnum fromValue(String value) {

      for (BootOrderEnum b : BootOrderEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<BootOrderEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final BootOrderEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public BootOrderEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return BootOrderEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_BOOT_ORDER = "bootOrder";
  @SerializedName(SERIALIZED_NAME_BOOT_ORDER)
  private BootOrderEnum bootOrder;


  public static final String SERIALIZED_NAME_IMAGE_PASSWORD = "imagePassword";
  @SerializedName(SERIALIZED_NAME_IMAGE_PASSWORD)
  private String imagePassword;

  

  public ReplicaVolumePost image(UUID image) {
    
    this.image = image;
    return this;
  }

   /**
   * The image installed on the disk. Currently, only the UUID of the image is supported.  &gt;Note that either &#39;image&#39; or &#39;imageAlias&#39; must be specified, but not both.
   * @return image
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "6e928bd0-3a8e-4821-a20a-54984b0c2d21", value = "The image installed on the disk. Currently, only the UUID of the image is supported.  >Note that either 'image' or 'imageAlias' must be specified, but not both.")

  public UUID getImage() {
    return image;
  }


  public void setImage(UUID image) {
    this.image = image;
  }



  public ReplicaVolumePost imageAlias(String imageAlias) {
    
    this.imageAlias = imageAlias;
    return this;
  }

   /**
   * The image installed on the volume. Must be an &#39;imageAlias&#39; as specified via the images API. Note that one of &#39;image&#39; or &#39;imageAlias&#39; must be set, but not both.
   * @return imageAlias
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "ubuntu:latest", value = "The image installed on the volume. Must be an 'imageAlias' as specified via the images API. Note that one of 'image' or 'imageAlias' must be set, but not both.")

  public String getImageAlias() {
    return imageAlias;
  }


  public void setImageAlias(String imageAlias) {
    this.imageAlias = imageAlias;
  }



  public ReplicaVolumePost name(String name) {
    
    this.name = name;
    return this;
  }

   /**
   * The replica volume name.
   * @return name
  **/
  @ApiModelProperty(example = "Volume 1", required = true, value = "The replica volume name.")

  public String getName() {
    return name;
  }


  public void setName(String name) {
    this.name = name;
  }



  public ReplicaVolumePost size(Integer size) {
    
    this.size = size;
    return this;
  }

   /**
   * The size of this replica volume in GB.
   * minimum: 1
   * @return size
  **/
  @ApiModelProperty(example = "30", required = true, value = "The size of this replica volume in GB.")

  public Integer getSize() {
    return size;
  }


  public void setSize(Integer size) {
    this.size = size;
  }



  public ReplicaVolumePost sshKeys(List<String> sshKeys) {
    
    this.sshKeys = sshKeys;
    return this;
  }

  public ReplicaVolumePost addSshKeysItem(String sshKeysItem) {
    if (this.sshKeys == null) {
      this.sshKeys = new ArrayList<String>();
    }
    this.sshKeys.add(sshKeysItem);
    return this;
  }

   /**
   * The SSH keys of this volume.
   * @return sshKeys
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The SSH keys of this volume.")

  public List<String> getSshKeys() {
    return sshKeys;
  }


  public void setSshKeys(List<String> sshKeys) {
    this.sshKeys = sshKeys;
  }



  public ReplicaVolumePost type(VolumeHwType type) {
    
    this.type = type;
    return this;
  }

   /**
   * Get type
   * @return type
  **/
  @ApiModelProperty(required = true, value = "")

  public VolumeHwType getType() {
    return type;
  }


  public void setType(VolumeHwType type) {
    this.type = type;
  }



  public ReplicaVolumePost userData(String userData) {
    
    this.userData = userData;
    return this;
  }

   /**
   * The user data (Cloud Init) for this replica volume.
   * @return userData
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "ZWNobyAiSGVsbG8sIFdvcmxkIgo=", value = "The user data (Cloud Init) for this replica volume.")

  public String getUserData() {
    return userData;
  }


  public void setUserData(String userData) {
    this.userData = userData;
  }



  public ReplicaVolumePost bus(BusType bus) {
    
    this.bus = bus;
    return this;
  }

   /**
   * Get bus
   * @return bus
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public BusType getBus() {
    return bus;
  }


  public void setBus(BusType bus) {
    this.bus = bus;
  }



  public ReplicaVolumePost backupunitId(String backupunitId) {
    
    this.backupunitId = backupunitId;
    return this;
  }

   /**
   * The ID of the backup unit that the user has access to. The property is immutable and is only allowed to be set on creation of a new a volume. It is mandatory to provide either &#39;public image&#39; or &#39;imageAlias&#39; in conjunction with this property.
   * @return backupunitId
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "25f67991-0f51-4efc-a8ad-ef1fb31a481c", value = "The ID of the backup unit that the user has access to. The property is immutable and is only allowed to be set on creation of a new a volume. It is mandatory to provide either 'public image' or 'imageAlias' in conjunction with this property.")

  public String getBackupunitId() {
    return backupunitId;
  }


  public void setBackupunitId(String backupunitId) {
    this.backupunitId = backupunitId;
  }



  public ReplicaVolumePost bootOrder(BootOrderEnum bootOrder) {
    
    this.bootOrder = bootOrder;
    return this;
  }

   /**
   * Determines whether the volume will be used as a boot volume. Set to NONE, the volume will not be used as boot volume. Set to PRIMARY, the volume will be used as boot volume and set to AUTO will delegate the decision to the provisioning engine to decide whether to use the voluem as boot volume. Notice that exactly one volume can be set to PRIMARY or all of them set to AUTO.
   * @return bootOrder
  **/
  @ApiModelProperty(example = "AUTO", required = true, value = "Determines whether the volume will be used as a boot volume. Set to NONE, the volume will not be used as boot volume. Set to PRIMARY, the volume will be used as boot volume and set to AUTO will delegate the decision to the provisioning engine to decide whether to use the voluem as boot volume. Notice that exactly one volume can be set to PRIMARY or all of them set to AUTO.")

  public BootOrderEnum getBootOrder() {
    return bootOrder;
  }


  public void setBootOrder(BootOrderEnum bootOrder) {
    this.bootOrder = bootOrder;
  }



  public ReplicaVolumePost imagePassword(String imagePassword) {
    
    this.imagePassword = imagePassword;
    return this;
  }

   /**
   * The image password for this replica volume.
   * @return imagePassword
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "passw0rd", value = "The image password for this replica volume.")

  public String getImagePassword() {
    return imagePassword;
  }


  public void setImagePassword(String imagePassword) {
    this.imagePassword = imagePassword;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ReplicaVolumePost replicaVolumePost = (ReplicaVolumePost) o;
    return Objects.equals(this.image, replicaVolumePost.image) && Objects.equals(this.imageAlias, replicaVolumePost.imageAlias) && Objects.equals(this.name, replicaVolumePost.name) && Objects.equals(this.size, replicaVolumePost.size) && Objects.equals(this.sshKeys, replicaVolumePost.sshKeys) && Objects.equals(this.type, replicaVolumePost.type) && Objects.equals(this.userData, replicaVolumePost.userData) && Objects.equals(this.bus, replicaVolumePost.bus) && Objects.equals(this.backupunitId, replicaVolumePost.backupunitId) && Objects.equals(this.bootOrder, replicaVolumePost.bootOrder) && Objects.equals(this.imagePassword, replicaVolumePost.imagePassword);
  }




  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ReplicaVolumePost {\n");
    
    sb.append("    image: ").append(toIndentedString(image)).append("\n");

    sb.append("    imageAlias: ").append(toIndentedString(imageAlias)).append("\n");

    sb.append("    name: ").append(toIndentedString(name)).append("\n");

    sb.append("    size: ").append(toIndentedString(size)).append("\n");

    sb.append("    sshKeys: ").append(toIndentedString(sshKeys)).append("\n");

    sb.append("    type: ").append(toIndentedString(type)).append("\n");

    sb.append("    userData: ").append(toIndentedString(userData)).append("\n");

    sb.append("    bus: ").append(toIndentedString(bus)).append("\n");

    sb.append("    backupunitId: ").append(toIndentedString(backupunitId)).append("\n");

    sb.append("    bootOrder: ").append(toIndentedString(bootOrder)).append("\n");

    sb.append("    imagePassword: ").append(toIndentedString(imagePassword)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

